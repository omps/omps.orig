<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Emacs | Om Prakash Singh]]></title>
  <link href="http://www.omps.in/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://www.omps.in/"/>
  <updated>2016-05-15T15:00:08+05:30</updated>
  <id>http://www.omps.in/</id>
  <author>
    <name><![CDATA[Om Prakash Singh]]></name>
    <email><![CDATA[omps@omps.in]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Day 10 - Search and Replace Using Regex]]></title>
    <link href="http://www.omps.in/blog/2016/01/20/day-10-search-and-replace-using-regex/"/>
    <updated>2016-01-20T21:44:31+05:30</updated>
    <id>http://www.omps.in/blog/2016/01/20/day-10-search-and-replace-using-regex</id>
    <content type="html"><![CDATA[<p>It is important that I am also should be able to search within my text/code when using the editor. Emacs have commands to search for occurrences of a string within the buffer and across the buffers. Emacs has the commands to replace occurrences of a string with a different string. Emacs provides the ability to search multiple files under the control of a tags table or through dired &lsquo;A&rsquo; command , or ask the &lsquo;grep&rsquo; program to do it.</p>

<!--more-->


<h2>Incremental Search</h2>

<p>All the searches done in Emacs are &ldquo;incremental&rdquo; in nature i.e. it starts searching as soon as we start typing the first character of the search string. As we start typing emacs shows where the string and as we type further, would be found. We can end our search using RETURN.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">C-s</td>
<td class="left">isearch-forward</td>
<td class="left">Incremental search forward</td>
</tr>

<tr>
<td class="left">C-r</td>
<td class="left">isearch-backward</td>
<td class="left">Incremental search backward</td>
</tr>
</tbody>
</table>


<p></div></p>

<h3>Basic incremental search</h3>

<p>Incremental search starts a forward incremental search. It reads characters from the keyboard, and moves point just past the end of the next occurrence of those characters in the buffer. When you type <code>C-s</code> and then F that puts the cursor after the first &lsquo;F&rsquo; that occurs in the buffer after the starting point then if you type O it moves the cursor to just after the FO. At each step emacs highlights, the &ldquo;current match&rdquo; â€“ the buffer text which matches the string &ndash; using the &lsquo;isearch&rsquo; face. The current search string is also displayed in the echo area. While we made mistake typing the search string, just press <code>&lt;DEL&gt;</code>. Each <code>&lt;DEL&gt;</code> cancels the last character of the search string. Once satified, press <RET> Typing <code>C-a</code> exits the search and moved to the beginning of the line.</p>

<p>As an exception, entering <RET> when the search string is empty launches nonincremental search.</p>

<p>When you exit the search, it add the original value of the point to the mark ring, without activating the mark; use <code>C-u C-&lt;SPC&gt;</code> to return to where you were before the beginning the search.</p>

<p>Use <code>C-r</code> to search backwards. A backward search finds matches that end before the starting point.</p>

<h3>Repeating incremental search</h3>

<p>Suppose you searched for some word &lsquo;FOO&rsquo; and find a match, but its not the one you expected to find, typing C-s again will jump to the next occurence of the word FOO, repeat this any number of time, till you reach the correct instance. If you overshoot(i.e. added more characters to the search string) your search string cancel the same using the <code>&lt;DEL&gt;</code> character, which will delete the last visible character in the search string. When you pause a little after typing your search string, Emacs highlights all the possible matches for the search string. This helps in anticipating how many &lsquo;C-s&rsquo; or &lsquo;C-r&rsquo; you may need to type before you end at the right search. The other matches are highlighted differently than the current match, this can be changes by customizing the face lazy-highlight. This feature can be disabled by setting isearch-lazy-highlight to nil.</p>

<p>Once exited from the search the same string can be used to search again using &lsquo;C-s C-s&rsquo; , the first &lsquo;C-s&rsquo; invokes the search, the second &lsquo;C-s&rsquo; means search again. The similar concepts can be applied while searching backward. While searching forward, you realise, that what you are looking for is before the starting point, you can easily switch with &lsquo;C-r&rsquo;.</p>

<p>To reuse a search string, use the &ldquo;search ring&rdquo;. The commands M-p and &rsquo;M-n' move through the ring to pick a search string to reuse. It leaves the selected search ring element in the minibuffer, which can then be edited. If we just need to edit the current search string in the minibuffer without replaying it with items from the search ring, type &rsquo;M-e', then type <RET>, &lsquo;C-s&rsquo; or &lsquo;C-r&rsquo; to finish editing and search for the string.</p>

<h3>Erros while incremental search</h3>

<p>After typing the search string and if the search string is not found in the buffer, the echo area will say Failing I-Search, and the cursor moves to the place where Emacs found as much of your string as it could. Thus, if you search for &lsquo;FOOT&rsquo; and there is no &lsquo;FOOT&rsquo; in the buffer, then the cursor would be placed after &lsquo;FOO&rsquo; in &lsquo;FOOL&rsquo;. While, in the echo area, the part of the search string that failed to match is highlighted using face isearch-fail. We can correct our string if it was mis-typed, if we liked the place where it is found we can remain there by pressing <RET> or can just remove the character from search string which cannot be found by typing &lsquo;C-g&rsquo;, so this will remove the &rsquo;T' in &lsquo;FOOT&rsquo; which could not be found and leaving those that are found. i.e will leave the &lsquo;FOO&rsquo; in &lsquo;FOOT&rsquo;, repressing &lsquo;C-g&rsquo; cancels the search altogether and return to the point where it was before the search has started.</p>

<h3>Special input for incremental search</h3>

<p>There are characters which has special effects when typed during incremental search. In default, the incremental search perform lax space matching i.e. each space, or sequence of spaces, matches any sequence of one or more spaces in the text. Hence, &lsquo;foo bar&rsquo; will match &lsquo;foo bar&rsquo;, &lsquo;foo bar&rsquo;, &lsquo;foo bar&rsquo;, and so on but it will not match &lsquo;foobar&rsquo;. Emacs matches each sequence of space characters in the match string to a regular expression specified by the variable search-whitespace-regexp. To toggle lax space matching &rsquo;M-s <SPC>&lsquo; isearch-toggle-lax-whitespace, and to disable this feature entirely set search-whitespace-regexp to nil, and then each single space will be matched to single space only.</p>

<p>By default the searches in emacs are case-insenitive, when there is an uppercase letter is present in search string, the searches become case-sensitive, once the upper case letter it deleted the search string becomes case-insensitive again.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">M-s i</td>
<td class="left">&#xa0;</td>
<td class="left">isearch-toggle-invisible</td>
</tr>

<tr>
<td class="left">C-s C-j</td>
<td class="left">&#xa0;</td>
<td class="left">search for newline character</td>
</tr>

<tr>
<td class="left">C-s C-\\</td>
<td class="left">isearch-toggle-input-method</td>
<td class="left">Toggle the input method</td>
</tr>

<tr>
<td class="left">C-s C-^</td>
<td class="left">isearch-toggle-specified-input-method</td>
<td class="left">prompts for the name of the input method.</td>
</tr>

<tr>
<td class="left">C-s M-%</td>
<td class="left">query-replace or query-replace-regexp</td>
<td class="left">with current search string used as a string to replace.</td>
</tr>

<tr>
<td class="left">C-s M-&lt;TAB&gt;</td>
<td class="left">isearch-complete</td>
<td class="left">tries to complete the search string using the search ring as a list of completion alternatives.</td>
</tr>

<tr>
<td class="left">C-s C-h C-h</td>
<td class="left">&#xa0;</td>
<td class="left">Interactive help.</td>
</tr>

<tr>
<td class="left">C-s C-y</td>
<td class="left">isearch-yank-kill</td>
<td class="left">Appends the current kill to the search string.</td>
</tr>

<tr>
<td class="left">C-s M-y</td>
<td class="left">isearch-yank-pop</td>
<td class="left">If called after 'C-y', replaces the appended text with an earlier kill, similar to usual 'M-y'.</td>
</tr>

<tr>
<td class="left">C-s C-w</td>
<td class="left">isearch-yank-word-or-char</td>
<td class="left">Appends the next character or word at point to the search string.</td>
</tr>

<tr>
<td class="left">C-s M-s C-e</td>
<td class="left">isearch-yank-line</td>
<td class="left">Appends the rest of the line to the search string. if point is already at the end of a line, it appends the next-line.</td>
</tr>

<tr>
<td class="left">C-s C-M-w</td>
<td class="left">isearch-del-char</td>
<td class="left">Deletes the last character from the search string.</td>
</tr>

<tr>
<td class="left">C-s C-M-y</td>
<td class="left">isearch-yank-char</td>
<td class="left">Appends the character after the point to the search string. Alternately, to add the character after point by entering minibuffer with '<b>M-e</b>' and type '<b>C-f</b>' at the end of the search string in the minibuffer</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Search for non-ASCII characters.</td>
</tr>

<tr>
<td class="left">C-q <b>non graphical character</b></td>
</tr>

<tr>
<td class="left">C-x 8 &lt;RET&gt;</td>
</tr>

<tr>
<td class="left">Use an INPUT Method, so if the INPUT method is enabled in the current buffer so when you start the search, you can use it in the seach string also.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>


<h3>Not exiting incremental search</h3>

<p>There are two categories of commands which you can type without exiting the current incremental search. They are</p>

<ul>
<li><p>Prefix arguments
With these arguments, by default it will apply either to the next action in the search or to the command that exits the search. When isearch-allow-prefix is set to nil, entering a prefix argument will terminate the search.</p></li>
<li><p>Scrolling commands
Scrolling commands exit search. changing variable <code>isearch-allow-scroll</code> to non-nil value, this enables the use of the scroll-bar as well as keyboard scrolling commands. The isearch-allow-scroll also afects some other commands, such as <code>C-x 2</code> and <code>C-x ^</code> which don&rsquo;t actually scroll but do affect where the text appears on the screen.</p></li>
</ul>


<h3>Searching the minibuffer</h3>

<p>If you start search while the minibuffer is active, Emacs searches the content of the minibuffer. If the search fails in the minibuffer, it tries searching the minibuffer history. The minibuffer can be visualized in series of pages. A forward search searches forward to later pages and similarly a reverse search does the backward search. If the current search is a history element, that history element is pulled in the minibuffer. Even you exit the incremental search by press RET, the point remains in the minibuffer unless it is specifically cancelled using C-g.</p>

<h2>Non Incremental search</h2>

<p>So we have visited how the incremental search works, i.e while you type the characters the emacs already begun it searching process and as every word gets added it moves you closer to what you are looking for, and if this is too annoying, emacs does have a conventional non-ncremental search, which require the complete string to present before it start searching.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybinding</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">C-s &lt;RET&gt; STRING &lt;RET&gt;</td>
<td class="left">search for string</td>
</tr>

<tr>
<td class="left">C-r &lt;RET&gt; STRING &lt;RET&gt;</td>
<td class="left">Search backward for string</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>


<p></div>
</div></p>

<h3>Search for word.</h3>

<p>A &ldquo;word search&rdquo; finds a sequence of words without regard to the type of punctuation between them. For instance, if you enter a search string that consists of two words seperated by a single space, the search matched any sequence of those two words separated by one or more spaces, newlines, or other punctiation characters. Useful for searching text documents where you do not have to worry about the words you are looking for and wether they are sperated by newlines of spaces.
</p></p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybinding</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">M-s-w</td>
<td class="left">isearch-toggle-word</td>
<td class="left">if incremental search is active toggle to word search mode.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">isearch-forward-searching</td>
<td class="left">begin and incremental forward word search.</td>
</tr>

<tr>
<td class="left">M-s-w &lt;RET&gt; WORDS &lt;RET&gt;</td>
<td class="left">&#xa0;</td>
<td class="left">similar to the non-incremenatal forward search.</td>
</tr>

<tr>
<td class="left">M-s w C-r &lt;RET&gt; WORDS &lt;RET&gt;</td>
<td class="left">&#xa0;</td>
<td class="left">similar to non-incremental backward search.</td>
</tr>
</tbody>
</table>


<p></div>
</div></p>

<h3>search for symbols.</h3>

<p>
It is just like normal search, except the boundaries of the search must match the boundaries of the symbol. This feature is mainly useful for searching the source code. 
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybinding</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">M-s</td>
<td class="left">isearch-toggle-symbol</td>
<td class="left">If active incremental search is, toggle symbol search mode.</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">isearch-forward-symbol</td>
<td class="left">else, begin an incremental forward search.</td>
</tr>

<tr>
<td class="left">M-s .</td>
<td class="left">&#xa0;</td>
<td class="left">Start incremental symbol searching forward with the symbol found at the point is added to the initial search.</td>
</tr>

<tr>
<td class="left">M-s \_ &lt;RET&gt; SYMBOL &lt;RET&gt;</td>
<td class="left">&#xa0;</td>
<td class="left">Searches forward for symbol non-incrementally.</td>
</tr>

<tr>
<td class="left">M-s \_ C-r &lt;RET&gt; SYMBOL &lt;RET&gt;</td>
<td class="left">&#xa0;</td>
<td class="left">Search backward for symbol non-incrementally.</td>
</tr>
</tbody>
</table>


<p></div>
</div></p>

<h3>search using regular expressions.</h3>

<p>
A regexp denotes a class of alternative strings to match. Emacs provides both incremental and non-incremental ways to search for a match for a regexp. Below is the syntax for regluar expressions.
</p>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">C-M-s</td>
<td class="left">isearch-forward-regexp</td>
<td class="left">Begin incrmental search.</td>
</tr>

<tr>
<td class="left">C-M-r</td>
<td class="left">isearch-backward-regexp</td>
<td class="left">Begin reverse incremental search.</td>
</tr>

<tr>
<td class="left">C-M-s &lt;RET&gt;</td>
<td class="left">re-search-forward</td>
<td class="left">non incremental forward search</td>
</tr>

<tr>
<td class="left">C-M-r &lt;RET&gt;</td>
<td class="left">re-search-backward</td>
<td class="left">non incremental backward search</td>
</tr>
</tbody>
</table>


<p></div></p>

<h2>Understanding Regular expressions (regex)</h2>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexps.html">The Emacs Regular Expression</a> have syntax in which a few characters are special constructs and the rest are ordinary. I will just go through the special constructs below, this would be similar to what the emacs tutorial says about regex, except I am putting it in the tabular format.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">

<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Regex</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">'.' (period)</td>
<td class="left">Matches any single character except a new line.</td>
</tr>

<tr>
<td class="left">'\*'</td>
<td class="left">Means to match preceding regular expression any no. of time as possible.</td>
</tr>

<tr>
<td class="left">'+'</td>
<td class="left">Matches the preceding expression atleast once.</td>
</tr>

<tr>
<td class="left">'?'</td>
<td class="left">Matches the expression either once or none.</td>
</tr>

<tr>
<td class="left">'\*?', '+?', '??'</td>
<td class="left">Non-greedy variants of above operators.</td>
</tr>

<tr>
<td class="left">'\\{N\\}'</td>
<td class="left">That the preceding regular expression matches exactly N times in a row.</td>
</tr>

<tr>
<td class="left">'\\{N,M\\}'</td>
<td class="left">Match N times but not more than M times.</td>
</tr>

<tr>
<td class="left">'[ &#x2026; ]'</td>
<td class="left">Set of character within the bracket.</td>
</tr>

<tr>
<td class="left">'[:char classes:]'</td>
<td class="left">Encloses character classes. [[</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>


<h2>Searching and cases</h2>

<p>While searching within emacs, emacs usually ignores the case of the text which is being searched through, when the search is specified in lower case, for example, searching for word &lsquo;nutrients&rsquo; so while typing the word in incremental search will match &lsquo;nutrients&rsquo; begining with either &lsquo;Nutri&rsquo; and &lsquo;nutri&rsquo;. Likewise, &lsquo;[ab]&rsquo; matches &lsquo;a&rsquo;, &lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;b&rsquo;. Any appearance of the uppercase letter within the search makes the searches case-sensisive, thus, searching for &lsquo;Nutri&rsquo; doesn&rsquo;t matches &lsquo;nutri&rsquo; and &lsquo;NUTRI&rsquo;. Typing <em>&rsquo;M-c'</em> within an incremental search toggles the case sensetivity of that search.</p>

<p>When we set <strong>case-fold-search</strong> to nil then all the letters must match exactly incuding the case. This is per-buffer variable, setting this variable to a particular buffer will only affect that buffer and will have no effects on the other buffers. The effect of this variable applies to non-incremental searches and to the replace commands as well.</p>

<h2>Replaement commands</h2>

<p>There is a simple replace command as <strong>M-x replace-string</strong> which replaces the occurunces in the buffer. <strong>M-% command</strong> is for query replace, which presents each occurence of the pattern and asks wether to replace it.</p>

<p>The replace command usually work from the point place where your cursor is to the end of the buffer. In an active region replace commands will work in that region only. The basic replace commands replaces one search string with one replacement string. <strong>expand-region-abbrevs</strong> makes emacs possible to perform several replacements in parellel. Replacement commands do not use lax space matching1 by default and can be enabled by changing the variable <strong>replace-lax-withespaces</strong> to <strong>t</strong>.</p>

<h3>Unconditional replacements</h3>

<table>
<thead>
<tr>
<th> Unconditional Replacements </th>
</tr>
</thead>
<tbody>
<tr>
<td> M-x replace-string RET string RET newstring RET | Replace all string with new string </td>
</tr>
</tbody>
</table>


<p>This replace every occurence of the string with the new string <em>from the point to the end of the buffer</em>. For doing this in the whole buffer, you must begin with the beginning2 of the buffer. In an active region the replacement is limited to the region.</p>

<h3>Regexp replacement</h3>

<p>Similarly,</p>

<table>
<thead>
<tr>
<th> Regexp replcatement commands. </th>
</tr>
</thead>
<tbody>
<tr>
<td> M-x replace-regexp RET regexp RET newstring | Replace every match for regexp with the new string. </td>
</tr>
</tbody>
</table>


<p>Here the newstring need not required to be constant: it can refer to all or part of the string as matched by the regex. &amp; in newstring stands for the entire match being replaced. \d in newstring where d = digit, stands for whatever matched the d/th/ parenthesized grouping in regexp, also called as backrefrence. # refers to the count of replacements already made in this command. \? will asks for the replacement string each time.</p>

<p><strong>Examples</strong>: M-x replace-regexp RET c[ad]+r RET &amp;-safe RET : replaces cadr with cadr-safe and cddr with cddr-safe M-x replace-regexp RET c[ad]+r-safe RET \1 RET: performs the inverse of above.</p>

<h3>Command and case</h3>

<p>Cases in emacs replace the similar way as it is in incremental search i.e. if the first argument of the replace command is all in lower case it ignores the cases. However, if the case-fold-search is set to nil, case would be significant in the searches.</p>

<h3>Query Replace</h3>

<table>
<thead>
<tr>
<th> Keybinding </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> M-% string RET newstring RET </td>
<td> Replaces some occurrences of string with newstring. </td>
</tr>
<tr>
<td> C-M-% regexp RET newstring RET </td>
<td> Replace some matches for regexp with new string. </td>
</tr>
</tbody>
</table>


<p>if you want to change only few occurrences and not all of them in the buffer the <strong>M-% (query-replace)</strong> will replace the words one by one and ask for your permission before doing it. Similarly, <strong>C-M-%</strong> performs performs regexp search and replace (query-replace-regexp). It works like replace-regexp except it queries like query-replace .</p>

<p>Character which are used when a match is shown in query-replace or <strong>query-replace-regexp</strong></p>

<table>
<thead>
<tr>
<th> Characters </th>
<th> Their actions while in query-replace </th>
</tr>
</thead>
<tbody>
<tr>
<td> SPC, y </td>
<td> Replace </td>
</tr>
<tr>
<td> DEL, n </td>
<td> Skip to next occurrence </td>
</tr>
<tr>
<td> , (comma) </td>
<td>   Replace and display result.</td>
</tr>
<tr>
<td> C-r </td>
<td> To undo the replaced text. C-x u can also be used. </td>
</tr>
<tr>
<td> RET, q </td>
<td>  Exit without doing any more replacements. </td>
</tr>
<tr>
<td> . (period) </td>
<td> Replace this one and exit, do not replace any more. </td>
</tr>
<tr>
<td> ! (exclamation) </td>
<td> Replace everything do not ask me again. </td>
</tr>
<tr>
<td> Y (UPPERCASE) </td>
<td> Replace all remaining occurrences in all remaining buffer in multi-buffer replacements </td>
</tr>
<tr>
<td> N (UPPERCASE) </td>
<td> Skip to the next buffer in the multi-buffer replacement without replacing remaining occurrences in the current buffer. </td>
</tr>
<tr>
<td> ^ (caret) </td>
<td> Go back to the position of the previous occurrences. </td>
</tr>
<tr>
<td> C-w </td>
<td> to delete the occurrences and enter into recursive editing level. </td>
</tr>
<tr>
<td> e </td>
<td> Edit the replacement string in the mini-buffer. This also becomes new replacement string for any further occurrences. </td>
</tr>
<tr>
<td> C-l </td>
<td> Re-display the screen. </td>
</tr>
<tr>
<td> C-h </td>
<td> Display message summarizing these options.</td>
</tr>
</tbody>
</table>


<h3>Some more commands for searching and looping</h3>

<table>
<thead>
<tr>
<th> Keybindings </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> M-x multi-search-buffers </td>
<td> Prompt for one or more buffer name ending with RET. Do an incremental search in all the buffers. </td>
</tr>
<tr>
<td> M-x multi-isearch-buffers-regexp </td>
<td> same as multi-isearch-buffer, except it performs incremental regexp search. </td>
</tr>
<tr>
<td> M-x occur </td>
<td> Prompt for a regexp and display a list showing each line in buffer that contains a match for it. To limit the search to part of the buffer, narrow to that part. In the occur buffer you can click on each entry or move point there and type RET, to visit the corresponding position in the buffer that was searched. o and C-o display the match in another window. Typing e in the occur buffer switches to occur edit mode, in which edits made to the entries are also applied to the text in originating buffer. Type C-c C-c to return to the occur mode. Command M-x list-matching-lines is synonymous to Occur mode. </td>
</tr>
<tr>
<td> M-s o </td>
<td> Run occur using the last used search string. Running M-s o when the search is active used the current search string. </td>
</tr>
<tr>
<td> M-x multi-occur </td>
<td> This command is like occur, except it is able to search through buffers. It asks for the buffer names one-by-one. </td>
</tr>
<tr>
<td> M-x multi-occur-in-matching-buffers </td>
<td> Same as multi-occur, except the buffers to search are specified by regular expression which matches visited file names. </td>
</tr>
<tr>
<td> M-x how-many </td>
<td> Prompt for regexp and print for the number of matches for it in the buffer for point. </td>
</tr>
<tr>
<td> M-x flush-lines </td>
<td> Prompt for regexp and delete the line which contains the match for it, operating on the text after point. This deletes the current line if it contains the match starting after point. </td>
</tr>
<tr>
<td> M-x keep-lines </td>
<td> Prompt for regexp and deletes the line which doesn&rsquo;t contain the match regexp. This command always keeps the current line where the match is found. </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 9 - Cut, Copy, Paste]]></title>
    <link href="http://www.omps.in/blog/2015/12/28/day-9-cut/"/>
    <updated>2015-12-28T21:32:41+05:30</updated>
    <id>http://www.omps.in/blog/2015/12/28/day-9-cut</id>
    <content type="html"><![CDATA[<p>As in my last post and coming posts I would be using org2blog to write content further to my blog sites and would further be writing about how to use customize it, in my later posts. This is a cool tool to use when you are writing and posting.</p>

<p>In my earlier days of using computers, copy and pasting something was such an interesting thing to do and the most innovative thing possibly could happen to computers. we just copy things around and move on. I started using emacs some couple of years back, and using it fully only some months back. So many things I learnt and learning. Believe me today, I am amused to know the possiblities cut and paste does have.</p>

<!--more-->


<p>In Emacs, killing means erasing the text and copying it into the &ldquo;kill ring&rdquo;. &ldquo;Yanking&rdquo; means bringing it back. The generalized terms for these are cutting and paste, copy and paste. Killing and yanking a text are the most common ways to move or copy text within emacs.</p>

<h1>Commands which remove text</h1>

<p>Most commands which erases text from the buffer saves it in the kill ring. These are known as &ldquo;kill&rdquo; commands. We usually on other editors or place also call it is cut. But Emacs, unlike other editors, stores several recents cuts and not just the last one, which makes killing a safe process, now I don&rsquo;t have to worry about loosing my text. Never felt this confident earlier while killing something. :) The kill ring is shared by all buffers , so the text that&rsquo;s killed is shared among all the buffers. &lsquo;C - /&rsquo; (undo) to undo a kill comannd and bring the killed text back into the buffer, but will keep the killed buffer in the kill ring and this can also be used elsewhere.</p>

<p>On graphical displays, killing some text back copies it to the system clipboard as well and then there are commands which kills the text but do not save it into the kill-ring are called as the delete command. &lsquo;C-d&rsquo; (delete-char) and &lsquo;DEL&rsquo; (delete-backward-character) will delete only one character at time, and those character which deletes only spaces or newlines, killing erase signigicant amount of nontrivial data and do a kill operation as mentioned above.</p>

<h3>Deletion</h3>

<p>This will erase the text and not saving in the kill ringh. In emacs, usually those command used for deletion, just delete a character at a time or whitspaces. Some of the delete commands to avoid future confusion.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">DEL or</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>


<tr>
<td class="left">Backspace</td>
<td class="left">delete-backward-char</td>
<td class="left">Delete the previous character or text in the region</td>
</tr>


<tr>
<td class="left">Delete</td>
<td class="left">delete-foward-char</td>
<td class="left">Delete the next character or the next in the region if it's active.</td>
</tr>


<tr>
<td class="left">C-d</td>
<td class="left">delete-char</td>
<td class="left">Delete the next character.</td>
</tr>


<tr>
<td class="left">M-\\</td>
<td class="left">delete-horizontal-space</td>
<td class="left">Delete spaces and tabs around point.</td>
</tr>


<tr>
<td class="left">M-SPC</td>
<td class="left">just-one-space</td>
<td class="left">Delete space and tabs around point leaving just one space.</td>
</tr>


<tr>
<td class="left">C-x C-o</td>
<td class="left">delete-blank-lines</td>
<td class="left">Delete blank lines aroung the current line.</td>
</tr>


<tr>
<td class="left">M-^</td>
<td class="left">delete-indentation</td>
<td class="left">Join two lines by deleting the intervening newline, along with and indentation following it.</td>
</tr>
</tbody>
</table>


<h3>Killing or cutting</h3>

<p>The simplest way to kill something is using the kill-command i.e. C-k (kill-line), this will invaribaly will remove anything from the point to the end of the line, the point is place where my cursor is, and everything from the cursor to the end of the line would be removed. If the cursor is at the end of the line, it kills the line ending the newline character, merging the next line into the current one; if point is at the beginning of the line, this leave the line blank.  Spaces and tabs are usually ignored while deciding the case to apply. As long as point is after the last visible character in the line, you can be sure that &lsquo;C-k&rsquo; will kill the newline; hence to kill an entire non-blank line, go to the beginning of the line and type &lsquo;C-k&rsquo; twice. This can also be done by giving the positive arguments to &lsquo;C-k&rsquo;, and with negative arguments it kill the previous lines before the point. &lsquo;C-k&rsquo; cannot be used to kill a character instead use the deletion commands above. Another way to kill the line and its new line is C-S-backspace, it kills regardless of the position where it is.</p>

<p>Killing a line acts as cutting line, and saving it into the kill-ring. Remember, killing a line can be recovered from the kill-ring, but not deleting the characters.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-k</td>
<td class="left">kill-line</td>
<td class="left">Kill the rest of the line from the point.</td>
</tr>


<tr>
<td class="left">C-S-backspace</td>
<td class="left">kill-whole-line</td>
<td class="left">Kill an entire line at once.</td>
</tr>


<tr>
<td class="left">C-w</td>
<td class="left">kill-region</td>
<td class="left">Kill the region as the name suggets.</td>
</tr>


<tr>
<td class="left">M-w</td>
<td class="left">kill-ring-save</td>
<td class="left">Copy the region into the kill ring.</td>
</tr>


<tr>
<td class="left">M-d</td>
<td class="left">kill-word</td>
<td class="left">kill the next word.</td>
</tr>


<tr>
<td class="left">M-DEL</td>
<td class="left">backward-kill-word</td>
<td class="left">Kill one word backwards</td>
</tr>


<tr>
<td class="left">C-x DEL</td>
<td class="left">backward-kill-sentence</td>
<td class="left">Kill back to the beginning of sentence.</td>
</tr>


<tr>
<td class="left">M-k</td>
<td class="left">kill-sentence</td>
<td class="left">Kill to the end of sentence.</td>
</tr>


<tr>
<td class="left">C-M-k</td>
<td class="left">kill-sexp</td>
<td class="left">Kill the following balanced sexp.</td>
</tr>


<tr>
<td class="left">M-z CHAR</td>
<td class="left">zap-to-char</td>
<td class="left">Kill through the next occurence of CHAR.</td>
</tr>
</tbody>
</table>


<p>M-w and C-w are commonly used commands, which kils text in the region and save it in kill-ring. M-w is the emacs copy command. The command M-z combines killing with searching, it read a character and kill from point up to the next occurence of that character in the buffer. A numeric argument would act as a repeat count; a negative argument meant search the text backward and kill text before point.</p>

<p>The are certain buffers which contain &lsquo;read-only text&rsquo; which cannot be modified and therefore cannot be killed, but the kill command still works. they move over text and save it into the kill-ring, without actually deleting the buffer. Normall, they will beep and display error message if this will happen. There may be times when we copy the similar text again, but if we change the varibale &lsquo;kill-do-not-save-duplicates&rsquo; to a non-nil value, identical subsequent killls would yeild a single kill-ring entry, without duplication.</p>

<h1>Commands which insert text</h1>

<p>It simply means pasting, and for theory, &ldquo;Yanking means reinserting text previously killed.&rdquo;</p>

<p>The basic yanking command is &lsquo;C-y&rsquo; (yank). It inserts the most recent kill, leaving the cursor at the end of the inserted text. It also sets the mark at the beginning of the inserted text, without activating it; this lets jumping to the posisition eaisly with &lsquo;C-u C-SPC&rsquo;. With &lsquo;C-u C-y&rsquo; it does exact opposite which means leaving the cursor in the front of the inserted text and sets the mark at the end. ON graphical display the yank command checks the clipboard if any other application has placed any text and is more recently than the last emacs kill.</p>

<h3>The kill ring</h3>

<p>The kill ring is a list of blocks of text that were previously killed. There is only one kill ring shared by all buffers, so we can kill(cut) text from one buffer and yank(paste) it in another buffer. The maximum no. of buffer stored in kill ring is controlled by the variable &lsquo;kill-ring-max&rsquo;. The default is 60. Emacs cycles the kill ring by removing the older entries if we reach the limit. The actual contents of the kill ring are stored in buffer &lsquo;kill-ring&rsquo; and can be viewed using &lsquo;C-h v kill-ring&rsquo;</p>

<h3>Yank(paste)ing earlier kills</h3>

<p>Numeric arguments can be used to yank a text that is no longer the most recent. If you remeber the kill entry you can eaisly yank it back. If you don&rsquo;t remember you can use &rsquo;M-y' (yank-pop) command to cycle through the possiblities. If the previous command was yank command, &rsquo;M-y' takes the text that was yanked and replaces it with the txt of the next-to-the-last kill, first use C-y to yank the last kill and then use M-y to replace it with the previous kill.</p>

<h3>Appending kills</h3>

<p>If two or more kill commands are run in a row, combines their text into a single entry n the kill ring, so a single &lsquo;C-y&rsquo; yanks all the text as a unit. Basically the commands that kill forward from point add onto the end of the previous killed text. Any sequence of mixed forward and backward kill commands puts all the killed text into one entry without rearrangement and Numeric arguments do not break the sequence of appending kills.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-y</td>
<td class="left">yank</td>
<td class="left">yank(paste) the last kill in the buffer</td>
</tr>


<tr>
<td class="left">M-y</td>
<td class="left">yank-pop</td>
<td class="left">replace the text just yanked with an earlier batch of killed text</td>
</tr>


<tr>
<td class="left">C-M-w</td>
<td class="left">append-next-kill</td>
<td class="left">Cause the following command if it is a kill command to append to previous kill</td>
</tr>
</tbody>
</table>


<h1>Cut and paste in X</h1>

<p>I have covered enough about copying, cutting and  pasting of the text, these all work expeceted in the terminal window, certain further operations are added while we are working with emacs GUI, they mainly involve usage of the OS clipboard along with the kill-ring. On a graphical display it eases us in transferring the data among other applications using clipboard. On X. two other similar facilities are available, known as primary selection and secondary selection, emacs running on the graphical system integrate with these facilities. Emacs by default uses UTF-8 encoding for interprogram text transfers. If you are not happy with the text you pasted(well, I meant the encoding here.) another coding system can be specified &lsquo;C-x RET x&rsquo; or &lsquo;C-x RET X&rsquo;. Let me briefly go through the available facilities.</p>

<h3>Clipboard</h3>

<p>Its a facility that most graphical applications use for &ldquo;cutting and pasting&rdquo;, when it exists emacs is going to use it for its kill and yank commands. When some text is killed or copied to kill-ring, the text is also placed in the clipboard. Usually, emacs wipes the clipboard clean before putting its contents in there, though this behavior can be modified by setting variable &lsquo;save-interprogram-paste-before-kill&rsquo; to t. This will allow emacs to first save the contents of the clipboard to its kill-ring before deleting it from the clipboard, preventing you from loosing critical data. Yank commands too uses the clipboard, so if someother program is using the clipboard.</p>

<h3>The Temp text selection or the Primary Selection</h3>

<p>When in X, there is a primary selection containing the last stretch of text selected, usually by dragging the mouse. This is usually seperate from the clipboard. The contents in this selection are changed over every new selection, whereas the clipboard changes is only possible by cutting, copying and pasting. Under X, when the region is active (i.e when primary selection is made or in other words the text is selected by dragging or clicking the mouse or by keyboard commands and moving point.)</p>

<h3>The Secondary selection</h3>

<p>The X Window system provides a second facility known as the secondary selection.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Mouse binding</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-Drag-Mouse-</td>
<td class="left">mouse-set-secondary</td>
<td class="left">With one end at the place where you press down the button, and the other end at the place where you release it. This text is highlighted using the \`secondary-selection\` face, as you drag. The windows scrolls automatically if you drag the mouse off the top or bottom of the window</td>
</tr>


<tr>
<td class="left">M-Mouse-1</td>
<td class="left">mouse-start-secondary</td>
<td class="left">set one endpoint for the secondary selection.</td>
</tr>


<tr>
<td class="left">M-Mouse-3</td>
<td class="left">mouse-secondary-save-then-kill</td>
<td class="left">Set the secondary selection, with one end at the position clicked and the other at the position specified with M-Mouse-1</td>
</tr>


<tr>
<td class="left">M-mouse-2</td>
<td class="left">mouse-yank-secondary</td>
<td class="left">Insert the secondary selection where you click, placing point at the end of the yanked text</td>
</tr>
</tbody>
</table>


<h2>Accumulating text</h2>

<p>The text can be moved by killing or yanking, but there are other ways that are also convinient methods for copying one block of text in many places, or for copying many scattered blocks of text in one place.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-x append-to-buffer</td>
<td class="left">Apend region to the contents of a specified buffer</td>
</tr>


<tr>
<td class="left">M-x prepend-to-buffer</td>
<td class="left">prepend region to the contents of a specified buffer</td>
</tr>


<tr>
<td class="left">M-x copy-to-buffer</td>
<td class="left">Copy regions into a specified buffer, deleting that buffers old contents.</td>
</tr>


<tr>
<td class="left">M-x insert-buffer</td>
<td class="left">Insert the content of a specified buffer into current buffer at point.</td>
</tr>


<tr>
<td class="left">M-x append-to-file</td>
<td class="left">Append region to the contents of a specified file at the end.</td>
</tr>
</tbody>
</table>


<p>M-x append-to-buffer, this reads the buffer name, then inserts a copy of the region into the buffer specified. If you specify non-existent buffer, `append-to-buffer` creates the buffer. The text is inserted whenever point is in that buffer.</p>

<p>Point in that buffer is left at the end of the copied text, so successive uses of `append-to-buffer` accumulate the text in the specified buffer in the same order as they were copied.  `prepend-to-buffer` is just like `append-to-buffer` except that point in the other buffer is left before the copied text, so successive prepending happens in the reverse order.</p>

<p>As it can append to buffer it can also accumulated the text directly to the file with &rsquo;M-x appened-to-file" only with the files which are not yet being visited to the file. because if we add it to the file we are editing in Emacs, would chnage the file behind Emacs&rsquo;s back and you can loose your precious editing.</p>

<h2>Rectangles</h2>

<p>&ldquo;Rectangle&rdquo; commands operate on rectangular areas of the text: and all of the characters between certain pair of columns, in a certain range of lines. In Emacs there are commands to operate on these rectangular areas, i.e to kill, yank and delete them off. These commands are useful with text in multicolumn formats, and for changing text into or out of such formats.</p>

<p>To specify a rectangle for a command to work on, set the mark at one corener and point at the opposite corener. This is called as the region-rectangle. If point and mark are in the same column, the rectangle region is considered empty.</p>

<p>The rectangle region is controlled in much similar way as the region  is controlled. But remember that a given combination of point and mark values can be interpreted as a region or as a rectangle.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Key bindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-x r k</td>
<td class="left">kill-rectangle</td>
<td class="left">kill the text of the rectangle region, and saving its contents to the "last-killed-rectangle"</td>
</tr>


<tr>
<td class="left">C-x r M-w</td>
<td class="left">copy-rectangle-as-kill</td>
<td class="left">Save the text of the region-rectangle as the last-killed-rectangle.</td>
</tr>


<tr>
<td class="left">C-x r d</td>
<td class="left">delete-rectangle</td>
<td class="left">Deletes the text of the region rectangle. The delete command works too.</td>
</tr>


<tr>
<td class="left">C-x r y</td>
<td class="left">yank-rectangle</td>
<td class="left">As the name suggests, it yanks the rectangle.</td>
</tr>


<tr>
<td class="left">C-x r o</td>
<td class="left">open-rectangle</td>
<td class="left">Insert blank space to fill the space of the region-rectangle.</td>
</tr>


<tr>
<td class="left">C-x r N</td>
<td class="left">rectangle-line-numbers</td>
<td class="left">Insert line numbers along the left edge of the region rectangle.</td>
</tr>


<tr>
<td class="left">C-x r c</td>
<td class="left">clear-rectangle</td>
<td class="left">CLear the region-rectangle by replacing all of its contents with spaces.</td>
</tr>


<tr>
<td class="left">M-x delete-whitespace-rectangle</td>
<td class="left">&#xa0;</td>
<td class="left">Delete whitespaces in each of the lines on the specified rectangle.</td>
</tr>


<tr>
<td class="left">C-x r t STRING <RET></td>
<td class="left">string-rectangle</td>
<td class="left">Replace rectangle contents with STRING on each line.</td>
</tr>


<tr>
<td class="left">M-x string-insert-rectangle <RET> STRING <RET></td>
<td class="left">&#xa0;</td>
<td class="left">Insert string on each line of the rectangle.</td>
</tr>
</tbody>
</table>


<h2>CUA Bindings</h2>

<p>Now, this is some interesting keybindings provided by emacs to its users who are migrating from windows or other editing systems. The command &rsquo;M-x cua-mode" sets up keybindings, that are compatible with the Common User Access (CUA) systems used in many other applications. When CUA mode is enabled the &lsquo;C-x&rsquo;, &lsquo;C-c&rsquo;, &lsquo;C-v&rsquo;, and &lsquo;C-z&rsquo; invoke commands that cut (kill), copy, paste(yank), and undo respectively. The &lsquo;C-x&rsquo; and &lsquo;C-c&rsquo; work only on the active regions. Otherwise they still act as the prefix keys and the standard emacs commands like &lsquo;C-x C-c&rsquo; still works.</p>

<p>To enter an Emacs command like `C-x C-f' while the mark is active, use one of the following methods: either hold `Shift' together with the prefix key, e.g., `S-C-x C-f', or quickly type the prefix key twice,e.g., `C-x C-x C-f'.</p>

<p>CUA mode provides enhanced rectangle support with visible rectangle highlighting.  Use `C-RET' to start a rectangle, extend it using the movement commands, and cut or copy it using `C-x' or `C-c'.  `RET' moves the cursor to the next (clockwise) corner of the rectangle, so you can easily expand it in any direction.  Normal text you type is
inserted to the left or right of each line in the rectangle (on the same side as the cursor).</p>

<p>With CUA you can easily copy text and rectangles into and out of registers by providing a one-digit numeric prefix to the kill, copy, and yank commands, e.g., `C-1 C-c' copies the region into register `1', and `C-2 C-v' yanks the contents of register `2'.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 8 - Mark and the Region]]></title>
    <link href="http://www.omps.in/blog/2015/12/26/day-8-mark/"/>
    <updated>2015-12-26T21:24:47+05:30</updated>
    <id>http://www.omps.in/blog/2015/12/26/day-8-mark</id>
    <content type="html"><![CDATA[<h1>Mark and the region<a id="sec-1" name="sec-1"></a></h1>

<p>Many command in Emacs operate on parts of the current buffer, to specify the text for such commands, we need to select the text, by marking it at one end of it and move the point to the other end. This text between the point and the mark is called as &ldquo;the region&rdquo; or &ldquo;the selection&rdquo;. This region always extend between the point and the mark, each time you move the point, the region changes.</p>

<!--more-->


<p>Setting the mark at the position also &ldquo;activates&rdquo; it. Emacs indicates the extent by highlighting the text within it, using the &lsquo;region&rsquo; face. Further on customizing it can be found under <span class="underline">Face Customization</span>.</p>

<p>Once the commands are run the region, Emacs automatically deactivates this region and turns off the highlighting; this can also be explicitly deactivate by typing &lsquo;C-g&rsquo;. Movement commands <sethyperlink>  doesn&rsquo;t work on the region. The behaviour is known as Transient Mark mode. Disabling mark mode switched Emacs to an alternate behaviour. Also, when you mark something in one buffer, it doesn&rsquo;t have effect in anyother buffer, so while you come back you will see the mark still present at the same buffer at same location.</p>

<p>Here are some commands for setting the mark; C is still the ctrl and M- is Meta or Alt or Esc key on your keyboard.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">keybindings</th>
<th scope="col" class="left">commands</th>
<th scope="col" class="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C - SPC</td>
<td class="left">set-mark-command</td>
<td class="left">Set the mark at point and activate it</td>
</tr>


<tr>
<td class="left">C - @</td>
<td class="left">&#xa0;</td>
<td class="left">The Same</td>
</tr>


<tr>
<td class="left">C-x C-x</td>
<td class="left">exchange-point-and-mark</td>
<td class="left">set the mark at point and activate it and move point where the mark used to be.</td>
</tr>


<tr>
<td class="left">Drag-Mouse-1</td>
<td class="left">&#xa0;</td>
<td class="left">Set the point and mark around the text you drag across.</td>
</tr>


<tr>
<td class="left">Mouse-3</td>
<td class="left">move-save-then-kill</td>
<td class="left">Set the mark at point, then move point to where you click.</td>
</tr>


<tr>
<td class="left">Shift and cursor motion keys</td>
<td class="left">&#xa0;</td>
<td class="left">set the mark at point if the mark is inactive, then move point</td>
</tr>
</tbody>
</table>


<p>OK, so now we know how to mark the text, but why really I want to do it, and learn so many combinations, when it can simply be done by holding and moving the mouse around, remind me of selecting text in browser; well, some real line usage is: say, you want to select some text and make it uppercase, so just select that area of text using any of the above key bindings and run C-x C-u, and you see all the characters becoming uppercase, neat isn&rsquo;t it, I can use this same mark to remember the text, but ofcourse I can select the position of my text in the buffer too, it reminds me something like bookmark, so for an example in a text file or a code of more than 1000 lines, I encounter something interesting, but have to move ahead also, for this I only see 2 ways, either select and copy the text and save it in some place, or just remember it, the emacs remember function just does that.  I selected a region and do not want to do anything with it as such, but just remember the position of the mark in the buffer type so I type &ldquo;C-SPC C-SPC&rdquo; just does that, i.e remember my position, and C-u C-SPC later jumps back to the mark. I will speak more about the mark ring further in Today itself.</p>

<p>Oh, now I know why I need it, but it may not be everytime I want to select the text and do something with it, so I activated the mark  by mistake using the key C-SPC and now wherever I move the cursor its just getting highlighted, and I am not sure what may happen if I type something, this is a time I really hate myself to be bought in, when I know how to enter into something, but do not know how to come out without making any unknown change. C-g comes to the rescue. It just is so cool, and a saviour isn&rsquo;t it.</p>

<p>Ah, there are endless commands in emacs, and if there aren&rsquo;t one you can always create one, its pretty simple. For eg. C-x C-x exchanges the positions of the point and the mark(I need to find out its practical use). And there are many ways too to set mark and selecting region
for eg. I can use mouse by pressing the left mouse button and moving around the text; clicking the right mouse button set the mark at point i.e first you click the left mouse button which will set the mark, right click to the place till where you want to make selection; further to this you can set the mark and use the cursor command or arrow keys to select the text. These are so cool tricks, I so despartley want to make video lessons now, nevermind will try to do some video lessons later once my 30 Days challenge is over.</p>

<p><em>Notes:</em>
<em>1. By any chance if your C-SPC is not working try using C-@ or vice-versa, this is also bound to the set mark command. I am not sure, but then some keyboards might not support C-SPC.</em></p>

<h2>Marking objects like word, list, paragraph or page.<a id="sec-2" name="sec-2"></a></h2>

<p>As we were taking earlier M-@ extend the mark on word and repeated invocation extend the region by advancing one word at a time and if the mark is active and located before point this same command moves the mark backward from its current position, one word at a time and while working with this we do not have to set the mark as well and it does accepts numeric arguments, so highlighting the next ten words would be C-u 10 M-@.</p>

<p>The Numerical argument and repeated invocation works with all the command mentioned in the table, ofcourse, not the last one which marks the whole buffer, I doubt repeated invocation would start marking other buffers too ;).</p>

<h2>Using the selected region and  Operating on the same<a id="sec-3" name="sec-3"></a></h2>

<ul>
<li>We can kill the region using C-w.</li>
<li>We can copy the region M-w.</li>
<li>Convert the case with C-x C-l or C-x C-u.</li>
</ul>


<p><em>as its already covered in my previous days, so I will save some effort explaining again.</em></p>

<ul>
<li>Undo change C-u C-/.</li>
<li>Replace text withing using M-%. (Yay!! I was wishing I could find something like this.)</li>
<li>Indent it with C-x TAB or C-M-\</li>
<li>Fill it as text with M-x fill-region.</li>
<li>Check the spelling M-$.</li>
<li>Evaluate the lisp code, if you have one M-x eval-region. (Got the similar tip sometime back on IRC, I was earlier while making changes to my .emacs. I was actually closing emacs and then opening again.)</li>
<li>Save it in a register. C-x r s.</li>
<li>and ofcourse save this region in some file. I will be coming to this soon.</li>
</ul>


<h1>The Mark Ring<a id="sec-4" name="sec-4"></a></h1>

<p>The command C-SPC C-SPC is hndy when you want to use the mark to remember a poistion if I wish to remember and may return to it later. It pushes the current point into the mark ring, without activating the mark. To return to the position, we can use &lsquo;set-mark-command&rsquo; with a prefix argument C-u C-SPC. This moves the point to where the mark was and deactivates the mark if it was active.Each subsequent C-u C-SPC jumps to a prior position stored in the mark ring.</p>

<p>Each buffer has its own mark ring. All editing command use the current buffer&rsquo;s mark ring. In particular, C-u C-SPC always stays in the same buffer.</p>

<h2>Marking texts globally<a id="sec-5" name="sec-5"></a></h2>

<p>Apart from the ordinary mark ring that belongs to each buffer, Emacs has aloso a single mark mode &ldquo;global mark ring&rdquo;. Each time the mark is set, this is recorded in the global mark ring in addition to the current buffer&rsquo;s own mark ring.</p>

<h2>Shift Selection<a id="sec-6" name="sec-6"></a></h2>

<p>If you hold down the shift key while typing a cursor motion command, the sets the mark before the moving point, so that the region extends from the original position of point to its new position. This feature is referred to as &ldquo;shift-selection&rdquo;. It is similar to text is selected in other editors.</p>

<p>To turn of shift selection, set &lsquo;shift-select-mode&rsquo; to &lsquo;nil&rsquo;</p>

<h2>Disabling transient mark mode<a id="sec-7" name="sec-7"></a></h2>

<p>Setting the mark activates and highlights the region, and is also called as Transient Mark mode. This is a minor mode and is enabled by default. It can be toggled with &rsquo;M-x transient-mark-mode' or with the &lsquo;Active Region Highlighting&rsquo; menu item from the options menu.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 7 - Commands for Human Languages and Editing Them]]></title>
    <link href="http://www.omps.in/blog/2015/12/20/day-7-commands-for-human-languages-and-editing-them/"/>
    <updated>2015-12-20T21:20:12+05:30</updated>
    <id>http://www.omps.in/blog/2015/12/20/day-7-commands-for-human-languages-and-editing-them</id>
    <content type="html"><![CDATA[<p>Emacs is wonderful for text editing and related stuff with text. It has many modes which helps in editing and managing text, which help increase the productive overall, here I explored some of the major modes and commands which can quickly help for editing text.</p>

<!--more-->


<h2>Text Editing in Emacs<a id="sec-1-1" name="sec-1-1"></a></h2>

<p>Emacs has several major modes for handelling text, there is text mode for ordinary text which customizes emacs in small ways for syntactic convention of text. Outline mode provides special commands to handle text, Org Mode extends Outline mode and turns emacs into a full fledged organizer: we can manage TODO Lists, store notes and publish them in many formats and I would speak more about this in my coming days learnings. TeX and LaTeX mode contains embedded commands; HTML mode for HTML and SGML Modes; nxml-mode for XML Mode; Nroff Mode for Groff and Nroff Mode.</p>

<p>It is also possible to edit pictures made out of text characters, also referred as *&ldquo;ASCII art&rdquo;* using Picture mode.</p>

<h2>Words<a id="sec-1-2" name="sec-1-2"></a></h2>

<p>There are several commnads in emacs for operating on words and many of these I have already covered in my Day-1 and Day-4, but let me redo, so I will remeber it for a long time.
Again, the <strong>M</strong> refers the Meta i.e the Alt or Esc key on the keyboard and is followed by the character keys.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Key bindings</th>
<th scope="col" class="left">commands</th>
<th scope="col" class="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-f</td>
<td class="left">forward-word</td>
<td class="left">Self descriptive as it moves forward on word</td>
</tr>


<tr>
<td class="left">M-b</td>
<td class="left">backward-word</td>
<td class="left">it moves one word back.</td>
</tr>


<tr>
<td class="left">M-d</td>
<td class="left">kill-word</td>
<td class="left">kills up to the end of the word</td>
</tr>


<tr>
<td class="left">M-<DEL></td>
<td class="left">backward-kill-word</td>
<td class="left">kill backward to the beginning of the word.</td>
</tr>


<tr>
<td class="left">M-@</td>
<td class="left">mark-word</td>
<td class="left">Mark to the end of the word</td>
</tr>


<tr>
<td class="left">M-t</td>
<td class="left">transpose-words</td>
<td class="left">Transpose the word and drag across others</td>
</tr>


<tr>
<td class="left">M-=</td>
<td class="left">count-words-region</td>
<td class="left">gives the count of the words in the region.</td>
</tr>
</tbody>
</table>


<p><em>NOTES:</em>
<em>1. These keys parrellel with the character-based movements</em>
<em>2. The numeric arguments serves as the repeat count and the negative arguments would make the commands move in the opposite direction.</em>
<em>3. M-<DEL> deletes the word to the point where M-b would end, it will kill the comma and space as well, M-b M-d to just kill the word but not the comma.</em>
<em>4. If we choose there keybindings in our shell <strong>(set -o emacs)</strong>, these word keybindings can help us in moving around the long commands.</em></p>

<h2>Sentences<a id="sec-1-3" name="sec-1-3"></a></h2>

<p>The meta keys are also helpful in moving around the sentences.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">commands</th>
<th scope="col" class="left">description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-a</td>
<td class="left">backward-sentence</td>
<td class="left">This will move the point to the beginning of the sentence</td>
</tr>


<tr>
<td class="left">M-e</td>
<td class="left">forward-sentence</td>
<td class="left">Will move forward to the end of sentence.</td>
</tr>


<tr>
<td class="left">M-k</td>
<td class="left">kill-sentence</td>
<td class="left">Kill forward to the end of the sentence.</td>
</tr>


<tr>
<td class="left">C-x <DEL></td>
<td class="left">backward-kill-sentence</td>
<td class="left">kill back to the beginning of the sentence.</td>
</tr>
</tbody>
</table>


<h3>Quoting from EMACS Manual<a id="sec-1-3-1" name="sec-1-3-1"></a></h3>

<p>#+BEGIN<sub>SRC</sub> Quote
 The sentence commands assume that you follow the American typist&rsquo;s
convention of putting two spaces at the end of a sentence.  That is, a
sentence ends wherever there is a `.&lsquo;, `?&rsquo; or `!&lsquo; followed by the end
of a line or two spaces, with any number of `)&rsquo;, `]&lsquo;, `&rsquo;&lsquo;, or `&ldquo;&rsquo;
characters allowed in between.  A sentence also begins or ends wherever
a paragraph begins or ends.  It is useful to follow this convention,
because it allows the Emacs sentence commands to distinguish between
periods that end a sentence and periods that indicate abbreviations.
\#+END<sub>SRC</sub> Quote</p>

<p><em>NOTE:</em>
<em>1. To use just one space between sentences, set the variable sentence-end-double-space to nil and to make the sentence commands stop for single spaces.</em>
<em>2. The variable sentence-end controls how to recognize the end of the sentence; its value is a regular expression, which is used to match the last few characters of the sentence.</em>
<em>3. Some languages such as Thai, doesn&rsquo;t end with periods; such cases can be handeld by setting variable sentence-end-without-period to t.</em></p>

<h2>Paragraphs<a id="sec-1-4" name="sec-1-4"></a></h2>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-{</td>
<td class="left">backward-paragraph</td>
<td class="left">move to the beginning of paragraph.</td>
</tr>


<tr>
<td class="left">M-}</td>
<td class="left">forward-paragraph</td>
<td class="left">Move to the end of the next paragraph.</td>
</tr>


<tr>
<td class="left">M-h</td>
<td class="left">mark-paragraph</td>
<td class="left">put point and mark around this or next paragraph.</td>
</tr>


<tr>
<td class="left">M-h C-w</td>
<td class="left">&#xa0;</td>
<td class="left">kills the paragraph around or after point.</td>
</tr>
</tbody>
</table>


<p><em>Notes:</em>
<em>1. The definition of a paragraph boundary is controlled by the variables <strong>paragraph-separate</strong> and  <strong>paragraph-start</strong>. The value of these are regular expression.</em>
<em>2. In fundamental mode, Paragraph-start is *&ldquo;\f\\|[ \t]*$&rdquo;* and matches lines that either start or separate paragraph.</em>
<em>3. Paragraph separate is *&ldquo;[ \t\f]*$&rdquo;* and matches lines  that separate paragraph without being part of any paragraph.</em></p>

<h2>Pages<a id="sec-1-5" name="sec-1-5"></a></h2>

<p>The files are divided into pages delimited by the &ldquo;formfeed character&rdquo; (ASCII code 2, denoted as <contorl-l>) and in emacs is escape sequence .</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-x What-page</td>
<td class="left">&#xa0;</td>
<td class="left">Display the page number and line number within that page</td>
</tr>


<tr>
<td class="left">C-x [</td>
<td class="left">backward-page</td>
<td class="left">Move point to the previous page boundary.</td>
</tr>


<tr>
<td class="left">C-x ]</td>
<td class="left">forward-page</td>
<td class="left">Move point ot next page boundary</td>
</tr>


<tr>
<td class="left">C-x C-p</td>
<td class="left">mark-page</td>
<td class="left">put point and mark around this page.</td>
</tr>


<tr>
<td class="left">C-x C-p C-w</td>
<td class="left">&#xa0;</td>
<td class="left">select and kill the page</td>
</tr>


<tr>
<td class="left">C-x l</td>
<td class="left">count-lines-page</td>
<td class="left">Count the lines in this page.</td>
</tr>
</tbody>
</table>


<p><em>Note:</em>
<em>page-delimiter control where the page begins. Its a regular expression *&ldquo;f&rdquo;* which matches a beginning of a line that separate pages.</em></p>

<h2>Filling Text<a id="sec-1-6" name="sec-1-6"></a></h2>

<p>Filling text means breaking up the lines that fit a specified width. Emacs does the filling in 2 ways. <strong>Auto Fill Mode</strong> inserts text with self-inserting characters and automatically fills it. <strong>Explicit fill Commands</strong>  can be used for editing texts.</p>

<h3>Auto Fill<a id="sec-1-6-1" name="sec-1-6-1"></a></h3>

<p>This is a minor mode in which the lines are broken automatically when they become too wide, breaking up of lines only happens when you type <SPC> or <RET>.</p>

<p>&rsquo;M-x auto-fill-mode' : Toggles the Auto Fill mode.</p>

<p>&lsquo;<SPC>/<RET>&rsquo; : Break lines when appropriate.</p>

<p>From the command line the auto-fill mode enables or disables the mode for current buffer. From LISP <em>auto-fill</em> is enabled when called with omitted or nil argument. for enabling in the major modes, add auto-fill-mode in mode hooks. When the mode it enabled it will show <strong>Fill</strong> in the mode line.</p>

<p>This mode breaks any line which goes longer than the desired width by pressing <SPC> or <RET>, and to insert a SPACE or any newline without breaking the lines tye <strong>C-q <SPC></strong> or <strong>C-q C-j</strong> and <strong>C-o</strong> for inserting new line.</p>

<p>Auto fill mode does not refill the paragraphs; it break lines but does not merge lines, editing in the middle of the paragraph can result in paragraph which is not correctly filled. To fill them correctly we may need to use explicit Fill Commands.</p>

<h3>Fill Commands<a id="sec-1-6-2" name="sec-1-6-2"></a></h3>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Key bindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-q</td>
<td class="left">fill-paragraph</td>
<td class="left">Fill current paragraph</td>
</tr>


<tr>
<td class="left">C-x f</td>
<td class="left">set-fill-column</td>
<td class="left">Set the fill column</td>
</tr>


<tr>
<td class="left">M-x fill-region</td>
<td class="left">fill-region</td>
<td class="left">Fill each paragraph in the region.</td>
</tr>


<tr>
<td class="left">M-x fill-region-as-paragraph</td>
<td class="left">&#xa0;</td>
<td class="left">Fill the region consider it as paragraph.</td>
</tr>


<tr>
<td class="left">M-o M-s</td>
<td class="left">&#xa0;</td>
<td class="left">Center a line.</td>
</tr>
</tbody>
</table>


<p><em>Notes:</em>
<em>1. M-q and fill-region uses the usual emacs criteria for finding paragraph boundaries, which refills everything between point and mark as single paragraph.</em>
<em>2. Numeric argument to <strong>M-q</strong> justifies the text as well as fill it.</em>
<em>3. To Remove extra spaces, use M-q with no argument.</em>
<em>4. The default vault for fill column is 70.</em>
<em>5. <strong>C-x f</strong> (sets-fill-column) sets the numeric value for fill column. With just C-u as argument it sets fill-column to the current horizantal position of point.</em>
<em>6. By default, emacs consider a period followed  by two spaces or by a newline as the end of sentence; a period with just one space will be called as abbrevation and not the end of the sentence.</em>
<em>7. Setting &lsquo;sentence-end-double-space&rsquo; to nil the fill commands will break a line after a period followed by a period and a space.</em></p>

<h3>The Fill Prefix<a id="sec-1-6-3" name="sec-1-6-3"></a></h3>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-x .</td>
<td class="left">set-fill-prefix</td>
<td class="left">Set the fill prefix</td>
</tr>


<tr>
<td class="left">M-q</td>
<td class="left">fill-paragraph</td>
<td class="left">Fill a paragraph using current fill prefix</td>
</tr>


<tr>
<td class="left">M-x fill-individual-paragraphs</td>
<td class="left">&#xa0;</td>
<td class="left">Fill the region, considering each change of indentation as starting a new paragraph.</td>
</tr>


<tr>
<td class="left">M-x fill-nonuniform-paragraphs</td>
<td class="left">&#xa0;</td>
<td class="left">Consider only paragraph separator lines as starting a new paragraph.</td>
</tr>
</tbody>
</table>


<p><em>Notes:</em>
<em>1. Move to a line which starts with desired prefix, put point at the end of the prefix and type C-x .</em>
<em>2. To turn off a prefix, specify an empty prefix: type C-x . with point at the beginning of line.</em>
<em>3. The fill prefix is stored in fill-prefix variable. if the value is nil, then there is no fill prefix.</em></p>

<p>This feature allows paragraphs to be filled so each line starts with a special string of characters (such a sequence of spaces, giving and indented paragraph). you can specify fill prefix explicitly; otherwise emacs tries to deduce automatically.</p>

<h3>Adaptive Fill.<a id="sec-1-6-4" name="sec-1-6-4"></a></h3>

<p>The fill command deduce the proper fill prefix for a paragraph automatically in some cases; either white spaces or certain precaution characters at the beginning of line are propagated to all lines of the paragraph.</p>

<p>If the paragraph has two or more lines, the fill prefix is taken from the paragraph&rsquo;s second line, but only if it appears on the first line as well.</p>

<p>If a paragraph has just one line, fill commands <span class="underline">may</span> take a prefix from that line.  The decision is complicated because there are three reasonable things to do in such a case:</p>

<ul>
<li><p>Use the first line&rsquo;s prefix on all the lines of the paragraph.</p></li>
<li><p>Indent subsequent lines with whitespace, so that they line up under the text that follows the prefix on the first line, but don&rsquo;t actually copy the    <br/>
prefix from the first line.</p></li>
<li><p>Don&rsquo;t do anything special with the second and following lines.</p></li>
</ul>


<p>All three of these styles of formatting are commonly used.  So the fill commands try to determine what you would like, based on the prefix that appears and on the major mode.  Here is how.</p>

<p>If the prefix found on the first line matches `adaptive-fill-first-line-regexp', or if it appears to be a comment-starting sequence (this depends on the major mode), then the prefix found is used for filling the paragraph, provided it would not act as a paragraph starter on subsequent lines.</p>

<p>Otherwise, the prefix found is converted to an equivalent number of spaces, and those spaces are used as the fill prefix for the rest of the lines, provided they would not act as a paragraph starter on subsequent lines.</p>

<p>In Text mode, and other modes where only blank lines and page delimiters separate paragraphs, the prefix chosen by adaptive filling never acts as a paragraph starter, so it can always be used for filling.</p>

<p>The variable `adaptive-fill-regexp' determines what kinds of line beginnings can serve as a fill prefix: any characters at the start of the line that match this regular expression are used.  If you set the variable `adaptive-fill-mode' to `nil', the fill prefix is never chosen automatically.</p>

<p>You can specify more complex ways of choosing a fill prefix automatically by setting the variable `adaptive-fill-function' to a function.  This function is called with point after the left margin of a line, and it should return the appropriate fill prefix based on that line.  If it returns `nil', `adaptive-fill-regexp' gets a chance to find a prefix.</p>

<h2>Case<a id="sec-1-7" name="sec-1-7"></a></h2>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-l</td>
<td class="left">downcase-word</td>
<td class="left">Convert the following word to lower case.</td>
</tr>


<tr>
<td class="left">M-u</td>
<td class="left">upcase-word</td>
<td class="left">Convert the following word to upper case.</td>
</tr>


<tr>
<td class="left">M-c</td>
<td class="left">capitalize-word</td>
<td class="left">Capitalize the following word.</td>
</tr>


<tr>
<td class="left">C-x C-l</td>
<td class="left">downcase-region</td>
<td class="left">Convert region to lowercase.</td>
</tr>


<tr>
<td class="left">C-x C-u</td>
<td class="left">upcase-region</td>
<td class="left">Convert region to upper case.</td>
</tr>
</tbody>
</table>


<p><em>Note:</em>
<em>1. When a negative argument, the case conversion applies to appropriate no. of words before point, but do not move the point, its convinent if I typed something in wrong case and want to correct the case.</em>
<em>2. In case the command to change case is given in the middle of the word, the case change would happen from the point to the end of the word.</em></p>

<h2>Text Mode<a id="sec-1-8" name="sec-1-8"></a></h2>

<p>This is the major mode for editing the text language, any file ending with .txt will automatically enables this mode; and this mode can also be called by M-x text-mode. Blank lines and page delimiters separate paragraphs, and as a result paragraphs can be indented, and adaptive filling determines what indentation to use when filling a paragraph. The <TAB> usually inserts whitespace up to the next tab stop, instead of indenting the current line.</p>

<p>Text mode turns off comments features except when you explicitly invoke them. It changes so that the single quotes are considered part of the words. But if a word starts with a single quote it is treated as a prefix for the purpose of capitalization. Entering text-mode invokes text-mode-hook.</p>

<h2>Outline Mode<a id="sec-1-9" name="sec-1-9"></a></h2>

<p>This is major mode derived from Text mode, which is specialized for editing outlines; it provides commands to navigate between entries in the outline structure. Type M-x outline-mode to switch to outline mode, entering this mode runs the hook text-mode-hook followed by outline-mode-hook.</p>

<p>When in outline mode use command to make a line invisible it disappears the line and ellipsis(three periods in a row) is displayed at the end of the previous visible line.</p>

<p>Editing command on lines, such as C-n and C-p treat the text of the invisible line as part of the previous visible line.</p>

<p>outline-minor-mode toggle outline minor mode in the current buffer, it is a buffer-local minor mode which provides the same commands as the major mode for the current buffer, this provides special keybindings with C-c prefix, and C-c @ as the prefix in minor-mode.</p>

<h3>Outline Format<a id="sec-1-9-1" name="sec-1-9-1"></a></h3>

<p>Outline mode assumes the the lines in the buffer are of two types:
&ldquo;heading lines&rdquo; and &ldquo;body lines&rdquo;</p>

<p>Heading line: start with one or more asterisk (&lsquo;*&rsquo;); the number of asterisks determines the depth of the heading in the outline structure.
Body Line: Any line which is not a heading line is a body line. Body line belong with a preceding heading line.</p>

<p>A heading line and a body line collectively is called as an entry.</p>

<h3>Outline mode commands<a id="sec-1-9-2" name="sec-1-9-2"></a></h3>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Key bindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-c C-n</td>
<td class="left">outline-next-visible-heading</td>
<td class="left">Move point to the next visible heading</td>
</tr>


<tr>
<td class="left">C-c C-p</td>
<td class="left">outline-previous-visible-heading</td>
<td class="left">Move point to the previous visible heading.</td>
</tr>


<tr>
<td class="left">C-c C-f</td>
<td class="left">outline-forward-same-level</td>
<td class="left">Move point to the next visible heading line at the same level.</td>
</tr>


<tr>
<td class="left">C-c C-b</td>
<td class="left">outline-backward-same-level</td>
<td class="left">Move point to previous heading line at the same level.</td>
</tr>


<tr>
<td class="left">C-c C-u</td>
<td class="left">outline-up-heading</td>
<td class="left">Move point up to a lower-level.</td>
</tr>
</tbody>
</table>


<h3>Outline visibility commands<a id="sec-1-9-3" name="sec-1-9-3"></a></h3>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-c C-c</td>
<td class="left">hide-entry</td>
<td class="left">Make the current heading line's body invisible</td>
</tr>


<tr>
<td class="left">C-c C-e</td>
<td class="left">show-entry</td>
<td class="left">Make the current heading line's body visible</td>
</tr>


<tr>
<td class="left">C-c C-d</td>
<td class="left">hide-subtree</td>
<td class="left">Make everything under the heading invisible excluding the heading</td>
</tr>


<tr>
<td class="left">C-c C-s</td>
<td class="left">show-subtree</td>
<td class="left">Make everything under the current heading visible</td>
</tr>


<tr>
<td class="left">C-c C-l</td>
<td class="left">hide-leaves</td>
<td class="left">Make the body of the current heading line, and all of its subheadings</td>
</tr>


<tr>
<td class="left">C-c C-k</td>
<td class="left">show-branches</td>
<td class="left">Make all subheading of the current heading line, at all levels, visible</td>
</tr>


<tr>
<td class="left">C-c C-i</td>
<td class="left">show-children</td>
<td class="left">Make immediate subheadings of the current heading line visible</td>
</tr>


<tr>
<td class="left">C-c C-t</td>
<td class="left">hide-body</td>
<td class="left">Make all body lines in the buffer invisible</td>
</tr>


<tr>
<td class="left">C-c C-a</td>
<td class="left">show-all</td>
<td class="left">Make all line in the buffer visible</td>
</tr>


<tr>
<td class="left">C-c C-q</td>
<td class="left">hide-sublevels</td>
<td class="left">Hide everything except the top N level of heading lines</td>
</tr>


<tr>
<td class="left">C-c C-o</td>
<td class="left">hide-other</td>
<td class="left">HIde everything except the heading or the body that point is in</td>
</tr>
</tbody>
</table>


<p>And most of these commands may work differently in org-mode, the org-mode is an advance implementation of outline-mode. I will be writing about this mode in my later days. It may confuse me at a later stage as mainly I use org-mode for my purposes of note taking and writing this blog. Let me provide some brief introduction to the org-mode.</p>

<h2>Org Mode<a id="sec-1-10" name="sec-1-10"></a></h2>

<p>Org mode, as in outline mode, each entry has a heading line that starts with one or more asterisk (*); Any line beginning with a &lsquo;#&rsquo; is considered as a comment. and it also provides commands to view and manipulate the outline structure.</p>

<p>The simplest of these commands is <TAB> (org-cycle). If invoked on heading line, it cycles through different visiblity states of that subtree:
1.  Showing only the heading line.
2.  Show only the heading lines and the heading lines of its direct children.
3.  Show the entire subtree.</p>

<p>The <S-TAB> (org-shifttab) in an org mode cycle visiblity of entire online subtree
1.  Show only top-level heading lines.
2.  Show all heading lines but no body lines.
3.  Show everything.</p>

<p>We can move the entire entry up and down in the buffer, including its body lines and subtree, by typing M-<up> (org-metaup) or M-<down> (org-metadown) on the heading line. Similarly, it can promote or demote the heading line with M-<left> (org-metaleft) and M-&lt;right (org-metaright). For details, The Org Mode Manual.</p>

<h3>Org as an Organizer<a id="sec-1-10-1" name="sec-1-10-1"></a></h3>

<p>You can tag an Org entry as a &ldquo;TODO&rdquo; by typing <strong>C-c C-t</strong> (org-todo) anywhere in the entry. This adds <em>TODO</em> keyword and typing the keyword <strong>C-c C-t</strong> again switches the keyword to <em>DONE</em>; press <strong>C-c C-t</strong> again and it will remove the keyword entirely. They keywords can be customized using the variable &lsquo;org-todo-keywords&rsquo;</p>

<p>With the possiblity of marking an entry as TODO, we can also attach a date to it by typing <strong>C-c C-s</strong> (org-schedule), This prompts for a date by popping a calendar, and then adds the tag &lsquo;SCHEDULED&rsquo;, together with the selected date, beneath the heading line. <strong>C-c C-d</strong> (org-deadline) have the same effect except it adds the tag &lsquo;DEADLINE&rsquo;.</p>

<p>Once you have some planned TODO items, you can add that file to the list of &ldquo;agenda fileS&rdquo; by typing <strong>C-c [</strong> (org-agenda-file-to-front). It allows us to maintain multiple agenda  files. The list of these agenda files are stored in the variable &lsquo;org-agenda-files&rsquo;.</p>

<p>Typing M-x org-agenda lets view items coming from agenda file, this command prompts for what we want to see: a list of things to do this week, a list of TODO items with specific keywords.</p>

<h3>Org as an authoring system<a id="sec-1-10-2" name="sec-1-10-2"></a></h3>

<p>To format org notes nicely and to prepare them for export and publication, <strong>C-c C-e</strong> (org-export) to export buffer and prompts for a export format; includes HTML, LaTeX, OpenDocument(.odt), and PDF.</p>

<p>To export several files at once to a specified directory, either locally or over the network, we can define a list of projects through the variable &lsquo;org-publish-project-alist&rsquo;</p>

<p>Org supports a simple markup scheme for applying text formatting to exported documents:</p>

<ul>
<li>This text is <em>emphasized</em></li>
<li>This text is <strong>in bold</strong></li>
<li>This text is <span class="underline">underlined</span></li>
<li>This text uses <code>a teletype font</code></li>
</ul>


<blockquote><p>``This is a quote.&lsquo;&rsquo;</p></blockquote>

<pre><code>This is an example.
</code></pre>

<h2>TeX Mode<a id="sec-1-11" name="sec-1-11"></a></h2>

<p>Emacs provides special major modes for editing files written in TeX and its related formats. TeX is a powerful text formatter written by Donald Knuth; like GNU Emacs. Latex is a simplified input format for TeX implemented using TeX macros. DocTeX is a special file format in which the LateX sources are written, combining sources with documentation.</p>

<p>TeX mode has four variants:
1.  Plain TeX mode
2.  LateX mode.
3.  DocTeX mode.
4.  SliTeX mode.</p>

<p>These distinc major modes differ only slightly, and are designed for editing the four different format. Emacs selects the appropriate mode by looking at the contents of the buffer. Emacs chooses the mode specified by the variable &lsquo;tex-default-mode&rsquo;; its default value is latex-mode. If Emacs doesn&rsquo;t get it right you can select the correct variant of TeX using the command &rsquo;M-x plain-tex-mode', &rsquo;M-x latex-mode', &rsquo;M-x slitex-mode', or &rsquo;M-x doctex-mode'.</p>

<h2>SGML and HTML Modes<a id="sec-1-12" name="sec-1-12"></a></h2>

<p>HTML mode is slightly customizable variant of SGML mode.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-C C-n</td>
<td class="left">sgml-name-char</td>
<td class="left">Interactively specify a special character and insert the SGML '&' command for that character</td>
</tr>


<tr>
<td class="left">C-c C-t</td>
<td class="left">sgml-tag</td>
<td class="left">Specify a tag and its attribute.</td>
</tr>


<tr>
<td class="left">C-c C-a</td>
<td class="left">sgml-attributes</td>
<td class="left">insert attribute value for the current tag</td>
</tr>


<tr>
<td class="left">C-c C-f</td>
<td class="left">sgml-skip-tag-forward</td>
<td class="left">skip across a balanced tag group.</td>
</tr>


<tr>
<td class="left">C-c C-b</td>
<td class="left">sgml-skip-tag-backward</td>
<td class="left">skip backward across a balanced tag group.</td>
</tr>


<tr>
<td class="left">C-c C-d</td>
<td class="left">sgml-delete-tag</td>
<td class="left">Delete the tag</td>
</tr>


<tr>
<td class="left">C-c ? TAG <RET></td>
<td class="left">sgml-tag-help</td>
<td class="left">display the description and the meaning of the tag</td>
</tr>


<tr>
<td class="left">C-c /</td>
<td class="left">sgml-close-tag</td>
<td class="left">insert a close tag for the innermost undetermind tag</td>
</tr>


<tr>
<td class="left">C-c 8</td>
<td class="left">sgml-name-8bit-mode</td>
<td class="left">Toggle a minor mode in which Latin-1 characters insert the corresponding SGML commands.</td>
</tr>


<tr>
<td class="left">C-c C-v</td>
<td class="left">sgml-validate</td>
<td class="left">run a shell commands to validate the current buffer as SGML.</td>
</tr>


<tr>
<td class="left">C-c <TAB></td>
<td class="left">sgml-tags-invisible</td>
<td class="left">Toggle the visiblity of existing tags in the buffer.</td>
</tr>
</tbody>
</table>


<p>There is a major mode for editing XML documents called as nXML mode. This is a mode which can recognize any XML schema and use them to provide completion on XML elements via &rsquo;M-<TAB>, as well as on the fly XML validation with error highlighting. To enable nXML mode for existing buffer type <strong>M-x nxml-mode</strong> or <strong>M-x xml-mode</strong></p>

<p>For files with extension .xml nxml-mode is used by default; and for files with xhtml html-mode is used.</p>

<h2>Nroff mode<a id="sec-1-13" name="sec-1-13"></a></h2>

<p>This is a major mode derived from Text mode and is specialized for editing nroff files e.g. UNIX man pages. <strong>M-x nroff-mode</strong> enters into this mode, and runs the hook &lsquo;text-mode-hook&rsquo;, then &lsquo;nroff-mode-hook&rsquo;; nroff command lines are treated as paragraph separators, pages are separated by &lsquo;.bp&rsquo; commands, and comments start with backslash-doublequote (\&ldquo;)</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Keybindings</th>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">M-n</td>
<td class="left">forward-next-line</td>
<td class="left">move to the beginning of next line, which is not a nroff command</td>
</tr>


<tr>
<td class="left">M-p</td>
<td class="left">backward-next-line</td>
<td class="left">same but moves up</td>
</tr>


<tr>
<td class="left">M-?</td>
<td class="left">count-text-lines</td>
<td class="left">display in the echo area the number of text lines.</td>
</tr>
</tbody>
</table>


<p><strong>M-x electric-nroff-mode</strong> toggles the Electric Nroff mode and is a minor-mode and can be used with Nroff mode.</p>

<h2>Enriched Text<a id="sec-1-14" name="sec-1-14"></a></h2>

<p>This is a minor mode for editing formatted text files in a WYSIWYG (&ldquo;what you see is what you get&rdquo;) fashion. When Enriched mode is enabled we can apply various formatting properties to the text in the buffer. This mode is typically used by Text mode and is not compatible with Font Lock Mode which is used by many major modes, for syntax highlighting. When you save a buffer with enriched mode enabled, it is saved using the &lsquo;text/enriched&rsquo; format, including the formatting indentation.</p>

<p>To create a new file of formatted text, visit file and type <strong>M-x enriched-mode</strong></p>

<h2>Editing Text Based Tables<a id="sec-1-15" name="sec-1-15"></a></h2>

<p>The table package provides commands to easily edit the text-based tables. A &ldquo;table&rdquo; consist of t a rectangular text area which is divided into &ldquo;cells&rdquo;. Each cell must be one character wide and one character high, not counting its border lines. A cell can be subdivided into more cells, but they cannot overlap.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Default</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">table-cell-vertical-char</td>
<td class="left">Pipe</td>
<td class="left">The character used for vertical lines.</td>
</tr>


<tr>
<td class="left">table-cell-horizontal-chars</td>
<td class="left">- =</td>
<td class="left">character used for horizontal lines.</td>
</tr>


<tr>
<td class="left">table-cell-intersection-char</td>
<td class="left">+</td>
<td class="left">character used for intersection of horizontal and vertical lines</td>
</tr>
</tbody>
</table>


<p>The following are examples of <span class="underline">invalid</span> tables:</p>

<!-- This HTML table template is generated by emacs 24.5.1 -->


<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />
      --+&nbsp;&nbsp;<br />
      &nbsp;&nbsp;|&nbsp;&nbsp;<br />
      &nbsp;&nbsp;|&nbsp;&nbsp;
    </td>
  </tr>
</table>


<p>a          b          c</p>

<p>From left to right:</p>

<ol>
<li><p>Overlapped cells or non-rectangular cells are not allowed.</p></li>
<li><p>The border must be rectangular.</p></li>
<li><p>Cells must have a minimum width/height of one character.</p></li>
</ol>


<h2>Two column editing<a id="sec-1-16" name="sec-1-16"></a></h2>

<p>Two columns lets you convinently edit two side-by-side columns of text. It uses two side-by-side windows, each showing its own buffer. There are three ways to enter two column mode:</p>

<ol>
<li><p><F2> 2 or C-x 6 2 - Enter two columns mode with the current buffer on the left and on the right, a buffer whose name is based on the current buffer&rsquo;s name.</p></li>
<li><p><F2> s  or C-x 6 s - Split the current buffer, which contains two column text, into two buffers and display them side by side.</p></li>
<li><p><F2> b BUFFER <RET> or C-x 6 b BUFFER <RET> - Enter two columns mode using the current buffer as the left-hand buffer, and using buffer BUFFER as the right-hand buffer.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Day 6 - Help and Run Command by Their Name]]></title>
    <link href="http://www.omps.in/blog/2015/12/13/day-6-help-and-run-command-by-their-name/"/>
    <updated>2015-12-13T21:09:38+05:30</updated>
    <id>http://www.omps.in/blog/2015/12/13/day-6-help-and-run-command-by-their-name</id>
    <content type="html"><![CDATA[<p>Sixth day of writing my content, I had never thought i would be even writing for this many posts continuously(I am kind of a lazy writer) and I realize this experience of writing blogs and sharing my learnings or acquired knowledge is actually encouraging. I started to think that if I am able to put some extra time and effort, I may also complete a lot of things by taking similar challenegs. <!--more-->My priority ones are loosing weight(I am still finding myself in tough situation on to get myself motivated) and learning the python programming language, which as I had been told is pretty easy to learning. I may get inconsistent at times due to other priorities coming up, but writing my learnings and posting everyday keeps me motivated and keep reminiding me I have pending stuff to do.</p>

<p>Every emacs command has a name which can be used against the convenient key bindings. Most emacs commands doesn&rsquo;t have key bindings so the only way to learn them is to use them as commands, by emacs convention all the command will consist one or more words separated  by &lsquo;-&rsquo;. For eg. auto-fill-mode or manual-entry. So to enter a command, type M-x enter the command name RET (to execute), C-g (to cancel). Its something similar to what we discussed in our Day 5, to enter the mini-buffer run the command and execute it and it does work similar for completion as it is to be done in mini-buffer.</p>

<p>well there are many things which we need immediately and overlook to take the effort to read the manual, or say for LISP errors which we might not be aware of, the freenode.org IRC network&rsquo;s #emacs channel is the best place after failed attempt of finding any help on google and emacswiki.org. but again at the same time emacs itself has a very awesome online documentation for reference. Online means it is accessible within emacs all the time. The help commands are easily accessible with &lsquo;C-h&rsquo; help character, after this we usually put the character for which we are seeking help and can be canceled the same way as all the mini-buffers. &lsquo;C-h&rsquo; itself a help option, so typing &lsquo;C-h C-h&rsquo; will print the available help characters. Apart from C-h, F1 can also  be used. I have put some simple stuff about how to ask help in Emacs at &lt;<a id="put-the-link-here" name="put-the-link-here"></a>. A more detailed list s below.</p>

<p>Similarly apropos are the commands which may answer certain questions as &ldquo;what are the commands for working with files?&rdquo;. specifying a apropos pattern such as a word, a list of words, or regular expressions, each apropos command display a list of item that matches the pattern in a separate window.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Commands</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>

<tbody>
<tr>
<td class="left">C-h a *TOPICS*</td>
<td class="left">Searched for the command whose name matches the arguments</td>
</tr>


<tr>
<td class="left">C-h i d m *emacs* RET i *TOPIC* RET</td>
<td class="left">This searches for the topic in the indices of online emacs manual, and prints the first match</td>
</tr>


<tr>
<td class="left">&#xa0;</td>
<td class="left">',' to jump to the subsequent matches, we can also use regexes here.</td>
</tr>


<tr>
<td class="left">C-h i d m *emacs* RET s *TOPIC* RET</td>
<td class="left">Same as above, but instead of just searching the indices, it searches the manual too.</td>
</tr>


<tr>
<td class="left">C-h C-f</td>
<td class="left">Displays the FAQ.</td>
</tr>


<tr>
<td class="left">C-h p</td>
<td class="left">Display all the emacs package based on the keywords.</td>
</tr>


<tr>
<td class="left">C-h b</td>
<td class="left">Display all active key bindings</td>
</tr>


<tr>
<td class="left">C-h c *key*</td>
<td class="left">show the name of the command it runs. (describe-key-briefly)</td>
</tr>


<tr>
<td class="left">C-h d *TOPICS* RET</td>
<td class="left">Display command and variables whose documentation matches topic. (aprops-documentation)</td>
</tr>


<tr>
<td class="left">C-h e</td>
<td class="left">Display **Message** Buffer</td>
</tr>


<tr>
<td class="left">C-h f *function* RET</td>
<td class="left">Display documentation on the LISP function (describe-function)</td>
</tr>


<tr>
<td class="left">C-h h</td>
<td class="left">Display the 'HELLO' file</td>
</tr>


<tr>
<td class="left">C-h i</td>
<td class="left">Run info, the GNU documentation browser, the complete emacs document is available online in info</td>
</tr>


<tr>
<td class="left">C-h key</td>
<td class="left">Display the name and the documentation of the command that the key runs. (describe-key)</td>
</tr>


<tr>
<td class="left">C-h l</td>
<td class="left">Description of last 300 keystrokes. (view-lossage)</td>
</tr>


<tr>
<td class="left">C-h f</td>
<td class="left">Display docuemntation of the current major mode. (describe-mode)</td>
</tr>


<tr>
<td class="left">C-h n</td>
<td class="left">Display news of recent changes. (view-emacs-news)</td>
</tr>


<tr>
<td class="left">C-h p</td>
<td class="left">find packages by topic keyword. ((finder-by-keyword)</td>
</tr>


<tr>
<td class="left">C-h r</td>
<td class="left">Display the emacs manual. (info-emacs-manual)</td>
</tr>


<tr>
<td class="left">C-h s</td>
<td class="left">Display the current contents of the syntax table, with explanation of what they mean</td>
</tr>


<tr>
<td class="left">&#xa0;</td>
<td class="left">(describe-syntax)</td>
</tr>


<tr>
<td class="left">C-h t</td>
<td class="left">enter the emacs interactive tutorial. (help-with-tutorial)</td>
</tr>


<tr>
<td class="left">C-h v *var* RET</td>
<td class="left">Display the doc for the LISP variable var. (describe-variable).</td>
</tr>


<tr>
<td class="left">C-h w *command* RET</td>
<td class="left">Show which keys run the command named command. (where-is)</td>
</tr>


<tr>
<td class="left">C-h C *coding* RET</td>
<td class="left">Describe the coding system. (describe-coding-system)</td>
</tr>


<tr>
<td class="left">C-h C RET</td>
<td class="left">Describe the coding system current in use.</td>
</tr>


<tr>
<td class="left">C-h F *COMMAND* RET</td>
<td class="left">Enter Info and go to node that documents emacs command *command*. (info-goto-emacs-command-node)</td>
</tr>


<tr>
<td class="left">C-h I *method* RET</td>
<td class="left">Describe the input *method*. (describe-input-method)</td>
</tr>


<tr>
<td class="left">C-h K *key*</td>
<td class="left">go to the key-sequence document in Info. (Infp-goto-emacs-key-command-node)</td>
</tr>


<tr>
<td class="left">C-h L *Language-env* RET</td>
<td class="left">Display info on the character set, coding system and input methods. (describe-language-environment)</td>
</tr>


<tr>
<td class="left">C-h S *Symbol* RET</td>
<td class="left">Display the info on the symbol *symbol* based on the programming mode you are using (info-lookup-symbol)</td>
</tr>


<tr>
<td class="left">C-h .</td>
<td class="left">Display message for the special text area. (display-local-help)</td>
</tr>


<tr>
<td class="left">**Apropos**</td>
<td class="left">&#xa0;</td>
</tr>


<tr>
<td class="left">C-h a *pattern* RET</td>
<td class="left">Search for command whose names matches the pattern.</td>
</tr>


<tr>
<td class="left">M-x apropos RET *pattern* RET</td>
<td class="left">Search for functions(both interactive and non-interactive) and variables whose name matches the *pattern*</td>
</tr>


<tr>
<td class="left">M-x apropos-variable RET *pattern* RET</td>
<td class="left">Search for a user-option variables matching the *pattern*.</td>
</tr>


<tr>
<td class="left">M-x apropos-value RET *pattern* RET</td>
<td class="left">search for function whose definition match *pattern* and variable whose value matches *pattern*</td>
</tr>


<tr>
<td class="left">C-h d *pattern* RET</td>
<td class="left">search for function and variable whose documentation string matches *pattern*</td>
</tr>


<tr>
<td class="left">**Emacs help files**</td>
<td class="left">&#xa0;</td>
</tr>


<tr>
<td class="left">C-h C-c</td>
<td class="left">Describe the emacs copying condition. rules for copying and redistributing emacs. (describe-copying)</td>
</tr>


<tr>
<td class="left">C-h C-d</td>
<td class="left">Debugging in emacs. (view-emacs-debugging)</td>
</tr>


<tr>
<td class="left">C-h g</td>
<td class="left">Display general information about GNU Project. (describe-gnu-project)</td>
</tr>


<tr>
<td class="left">C-h C-m</td>
<td class="left">How to order printed copies. (view-order-manual)</td>
</tr>


<tr>
<td class="left">C-h C-n</td>
<td class="left">To see the emacs news and listing of new features. (view-emacs-news)</td>
</tr>


<tr>
<td class="left">C-h C-o</td>
<td class="left">How to get new version. (describe-distribution)</td>
</tr>


<tr>
<td class="left">C-h C-p</td>
<td class="left">Tells us about the known emacs problems. (view-emacs-problems)</td>
</tr>


<tr>
<td class="left">C-h C-t</td>
<td class="left">Display the emacs TODO list, or things that needs to be done. (view-emacs-todo)</td>
</tr>


<tr>
<td class="left">C-h C-w</td>
<td class="left">Describe warranty. (describe-no-warranty)</td>
</tr>


<tr>
<td class="left">**Commands work in Help mode**</td>
<td class="left">&#xa0;</td>
</tr>


<tr>
<td class="left">SPC</td>
<td class="left">Scroll forward</td>
</tr>


<tr>
<td class="left">DEL</td>
<td class="left">Scroll backard</td>
</tr>


<tr>
<td class="left">TAB</td>
<td class="left">Move point forward to next cross refrence</td>
</tr>


<tr>
<td class="left">S-TAB</td>
<td class="left">Move point backward to previous reference</td>
</tr>


<tr>
<td class="left">RET</td>
<td class="left">Follow a cross refrence point.</td>
</tr>


<tr>
<td class="left">C-c C-c</td>
<td class="left">Show all documents of symbol at the point.</td>
</tr>
</tbody>
</table>


<p>I just completed through the help documentation in emacs manual, and I am convinced the emacs has got the most extensive documentation an editor could ever have, the above table tries to cover as many things as possible but I am pretty sure, I would have definitely missed things, like this that once on IRC I had been suggested some lisp code to quickly take me to the help page and I missed it. Well, on many modern keyboards F1 as well works to call the help function.</p>

<p>While doing the typing I do make a lot of mistakes and undo is the most fundamental command for correcting the mistakes. C-/ does the same trick as C-x u and C-_ all meant to undo my work. If you see the buffers have been modified accidentaly, the easiest way is to press <strong>C-/</strong> repetadely unless the stars disappears from the mod line. Just press <strong>C-/</strong> to see the last change, so that we can understand if the change was intentional, if yes then we can leave it like this, if no then we can undo by pressing <strong>C-/</strong> repeatedly.</p>

<p>Its much easier to transpose characters in emacs using *C-t*(transpose-chars)  and transpose words using *M-t*(transpose-words) and moves the word containing or preceding point forward as tell, though it does not move any punctutation mark, for eg, FOO, BAR will become BAR, FOO. *C-M-t*(transpose-sexps) is similar to transposing two expressions and *C-x C-t*(transpose-lines) for transposing lines. The numeric command works here, it tell the transpose command to move forward the character before or containing point across several other characters.</p>

<p><strong>M&#x2013; M-l</strong> Convert last word to lower-case, it is Meta-Minus. <strong>M&#x2013; M-u</strong> Convert last word to uppercase. <strong>M&#x2013; M-c</strong> convert last word to lowercase with capital letters.</p>

<p>The spell checking ability of any editor should be good for the writer to help check spells on the fly, and emacs does have some nifty commands to do that as well. We need aspell, ispell, hunspell installed on the system for these commands to work. Once started the programs continue to run so that subsequent spell check commands complete more quickly and can be killed using <strong>M-x ispell-kill-ispell</strong> but is not required as it does not uses much memory and only active when spelling correcting is done, these programs using two dictionaries one is the standard dictionary and the other is our defined dictionary. The local dictionary can be defined by &ldquo;ispell-local-dictionary* or if nil by "ispell-dictionary&rdquo; or if both is nil then the default dictinary is selected. The variable &ldquo;ispell-complete-word-dict&rdquo; specifies the file name for its dictionary and is used for word completion. Flyspell mode is fully automatic mode of checking the words in the buffer as we insert them or edit them, when it finds the words it doesn&rsquo;t recognize it highlights that word. Right now I am seeing my buffer so colorful, thanks to flyspell mode, and my typing :). <strong>M-x flyspell-mode</strong> toggles the flyspell mode, to turn on flyspell mode for all text buffer <strong>turn-on-flyspell-mode</strong> to <strong>text-mode-hook</strong>.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Key binding</td>
<td class="left">command</td>
<td class="left">Description</td>
</tr>


<tr>
<td class="left">M-$</td>
<td class="left">ispell-word</td>
<td class="left">check and correct spelling of active region or word at point.</td>
</tr>


<tr>
<td class="left">M-x ipsell</td>
<td class="left">&#xa0;</td>
<td class="left">check or correct spelling in active region or entire buffer.</td>
</tr>


<tr>
<td class="left">M-x ispell-buffer</td>
<td class="left">&#xa0;</td>
<td class="left">check and correct spelling in the buffer.</td>
</tr>


<tr>
<td class="left">M-x ispell-region</td>
<td class="left">&#xa0;</td>
<td class="left">check and correct spelling in the region.</td>
</tr>


<tr>
<td class="left">M-x ispell-message</td>
<td class="left">&#xa0;</td>
<td class="left">check and correct spelling in the draft message, excluding citied content</td>
</tr>


<tr>
<td class="left">M-x ispell-change-dictionary RET *Dictionary* RET</td>
<td class="left">&#xa0;</td>
<td class="left">restart ispell/aspell/hunspell using dict as dictionary.</td>
</tr>


<tr>
<td class="left">M-x ispell-kill-ispell</td>
<td class="left">&#xa0;</td>
<td class="left">kill the dictionary process</td>
</tr>


<tr>
<td class="left">M-TAB / ESC-TAB</td>
<td class="left">ispell-complete-word</td>
<td class="left">complete the word based on the dictinary</td>
</tr>


<tr>
<td class="left">M-x flyspell-mode</td>
<td class="left">&#xa0;</td>
<td class="left">enable flyspell mode which highlights misspelled words</td>
</tr>


<tr>
<td class="left">M-x flyspell-prog-mode</td>
<td class="left">&#xa0;</td>
<td class="left">enable flyspell mode for comments and strings only</td>
</tr>
</tbody>
</table>


<p>When the commands encounter the errors in case of misspelled words, it usually display the numbered &ldquo;near-misses&rdquo; close to the incorrect word, then we have to choose the valid response from the below list.</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">digit</td>
<td class="left">replace the word, just this time, with one of the near misses, the near misses are displayed by no. and the no. can be used to select it.</td>
</tr>


<tr>
<td class="left">SPC</td>
<td class="left">skip this word, continue to consider incorrect and don't change.</td>
</tr>


<tr>
<td class="left">r *NEW* RET</td>
<td class="left">replace the word just this time, with the new word.</td>
</tr>


<tr>
<td class="left">R *NEW* RET</td>
<td class="left">replace the word and do query-replace so it can be replaced everywhere.</td>
</tr>


<tr>
<td class="left">a</td>
<td class="left">accept the incorrect word, treat it as correct one, but only in this editing session</td>
</tr>


<tr>
<td class="left">A</td>
<td class="left">same as above but include the buffer too.</td>
</tr>


<tr>
<td class="left">i</td>
<td class="left">insert this word in my private dictionary, so it can be treated as a correct word by my spell check applications</td>
</tr>


<tr>
<td class="left">m</td>
<td class="left">like i</td>
</tr>


<tr>
<td class="left">u</td>
<td class="left">save the lowercase version of this word to my private dictionary</td>
</tr>


<tr>
<td class="left">l *word* RET</td>
<td class="left">Look in the dictinary for the word that match *word*. these words become new list for near-misses.</td>
</tr>


<tr>
<td class="left">C-g X</td>
<td class="left">quit interactive spell checking</td>
</tr>


<tr>
<td class="left">C-g x</td>
<td class="left">quit interactive spell checking and move point back to where it was when you started spell checking.</td>
</tr>


<tr>
<td class="left">C-g q</td>
<td class="left">quit spell checking and kill the sub process as well.</td>
</tr>


<tr>
<td class="left">?</td>
<td class="left">show the list of options.</td>
</tr>
</tbody>
</table>


<p>Well. I am done for the Day 6, being emacs is such a vast entity as an editor, i spend most of my time going through the help document and manual pages only and enable myself to write quality content, which should help me or any one else who might want to use my content for his/her reference. I am still at a very primitive level of doing things with emacs, but I am aware I am still to young here. I will put these text on git hub as well, for anyone to help me correcting the content or if adding anything more.</p>
]]></content>
  </entry>
  
</feed>
